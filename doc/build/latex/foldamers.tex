%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,12pt,english,openany,oneside]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
\edef\sphinxdqmaybe{\ifdefined\DeclareUnicodeCharacterAsOptional\string"\fi}
  \DeclareUnicodeCharacter{\sphinxdqmaybe00A0}{\nobreakspace}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2500}{\sphinxunichar{2500}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2502}{\sphinxunichar{2502}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2514}{\sphinxunichar{2514}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe251C}{\sphinxunichar{251C}}
  \DeclareUnicodeCharacter{\sphinxdqmaybe2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}
\usepackage{times}
\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}

\addto\captionsenglish{\renewcommand{\figurename}{Fig.}}
\addto\captionsenglish{\renewcommand{\tablename}{Table}}
\addto\captionsenglish{\renewcommand{\literalblockname}{Listing}}

\addto\captionsenglish{\renewcommand{\literalblockcontinuedname}{continued from previous page}}
\addto\captionsenglish{\renewcommand{\literalblockcontinuesname}{continues on next page}}
\addto\captionsenglish{\renewcommand{\sphinxnonalphabeticalgroupname}{Non-alphabetical}}
\addto\captionsenglish{\renewcommand{\sphinxsymbolsname}{Symbols}}
\addto\captionsenglish{\renewcommand{\sphinxnumbersname}{Numbers}}

\addto\extrasenglish{\def\pageautorefname{page}}

\setcounter{tocdepth}{1}



\title{foldamers Documentation}
\date{Sep 08, 2019}
\release{0.0}
\author{Garrett A. Meek\\Theodore L. Fobe\\Connor M. Vogel\\ \\Research group of Professor Michael R. Shirts\\ \\Dept. of Chemical and Biological Engineering\\University of Colorado Boulder}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\maketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}


This documentation is generated automatically using Sphinx, which reads all docstring-formatted comments from Python functions in the ‘foldamers’ repository.  (See foldamers/doc for Sphinx source files.)


\chapter{Coarse grained model utilities}
\label{\detokenize{cg_model:coarse-grained-model-utilities}}\label{\detokenize{cg_model::doc}}
The foldamers package uses “CGModel()” objects to define and store information about the properties of coarse grained models.


\section{‘basic\_cgmodel’: a simple function to build coarse grained homopolymers}
\label{\detokenize{cg_model:basic-cgmodel-a-simple-function-to-build-coarse-grained-homopolymers}}
Shown below is the ‘basic\_cgmodel’ function, which requires a minimal set of input arguments to build a coarse grained holopolymer model.

\phantomsection\label{\detokenize{cg_model:module-cg_model.cgmodel}}\index{cg\_model.cgmodel (module)@\spxentry{cg\_model.cgmodel}\spxextra{module}}\index{basic\_cgmodel() (in module cg\_model.cgmodel)@\spxentry{basic\_cgmodel()}\spxextra{in module cg\_model.cgmodel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.basic_cgmodel}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{cg\_model.cgmodel.}}\sphinxbfcode{\sphinxupquote{basic\_cgmodel}}}{\emph{polymer\_length=12, backbone\_length=1, sidechain\_length=1, sidechain\_positions={[}0{]}, mass=Quantity(value=100.0, unit=dalton), bond\_length=Quantity(value=0.75, unit=nanometer), sigma=Quantity(value=1.85, unit=nanometer), epsilon=Quantity(value=0.5, unit=kilocalorie/mole), positions=None}}{}~\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{polymer\_length}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Number of monomer units, default = 8

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{backbone\_length}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Number of beads in the backbone for individual monomers within a coarse grained model, default = 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sidechain\_length}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Number of beads in the sidechain for individual monomers within a coarse grained model, default = 1

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sidechain\_positions}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{( }}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{ )}}) \textendash{} Designates the indices of backbone beads upon which we will place sidechains, default = {[}0{]} (add a sidechain to the first backbone bead in each monomer)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{mass}} (\sphinxhref{http://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}) \textendash{} Mass for all coarse grained beads, default = 100.0 * unit.amu

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{bond\_length}} \textendash{} Defines the length for all bond types, default = 7.5 * unit.angstrom

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{sigma}} \textendash{} Lennard-Jones equilibrium interaction distance (by default, calculated for particles that are separated by 3 or more bonds), default = 18.5 * bond\_length (for all interaction types)

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{epsilon}} \textendash{} Lennard-Jones equilibrium interaction energy (by default, calculated for particles that are separated by 3 or more bonds), default = 0.5 * unit.kilocalorie\_per\_mole

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{positions}} \textendash{} Positions for coarse grained particles in the model, default = None

\end{itemize}

\item[{Returns}] \leavevmode
cgmodel: CGModel() class object

\item[{Return type}] \leavevmode
class

\end{description}\end{quote}

..warning:: this function has significant limitations, in comparison with building a coarse grained model with the CGModel() class.  In particular, this function makes it more difficult to build heteropolymers, and is best-suited for the simulation of homopolymers.
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{simtk} \PYG{k}{import} \PYG{n}{unit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{polymer\PYGZus{}length} \PYG{o}{=} \PYG{l+m+mi}{20}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{backbone\PYGZus{}length} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sidechain\PYGZus{}length} \PYG{o}{=} \PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sidechain\PYGZus{}positions} \PYG{o}{=} \PYG{p}{[}\PYG{l+m+mi}{0}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{mass} \PYG{o}{=} \PYG{l+m+mf}{100.0} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{amu}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bond\PYGZus{}length}\PYG{o}{=}\PYG{l+m+mf}{0.75} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{nanometer}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sigma}\PYG{o}{=}\PYG{l+m+mf}{1.85}\PYG{o}{*}\PYG{n}{unit}\PYG{o}{.}\PYG{n}{nanometer}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{epsilon}\PYG{o}{=}\PYG{l+m+mf}{0.5} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{kilocalorie\PYGZus{}per\PYGZus{}mole}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cgmodel} \PYG{o}{=} \PYG{n}{basic\PYGZus{}cgmodel}\PYG{p}{(}\PYG{n}{polymer\PYGZus{}length}\PYG{o}{=}\PYG{n}{polymer\PYGZus{}length}\PYG{p}{,}\PYG{n}{backbone\PYGZus{}length}\PYG{o}{=}\PYG{n}{backbone\PYGZus{}length}\PYG{p}{,}\PYG{n}{sidechain\PYGZus{}length}\PYG{o}{=}\PYG{n}{sidechain\PYGZus{}length}\PYG{p}{,}\PYG{n}{sidechain\PYGZus{}positions}\PYG{o}{=}\PYG{n}{sidechain\PYGZus{}positions}\PYG{p}{,}\PYG{n}{mass}\PYG{o}{=}\PYG{n}{mass}\PYG{p}{,}\PYG{n}{bond\PYGZus{}length}\PYG{o}{=}\PYG{n}{bond\PYGZus{}length}\PYG{p}{,}\PYG{n}{sigma}\PYG{o}{=}\PYG{n}{sigma}\PYG{p}{,}\PYG{n}{epsilon}\PYG{o}{=}\PYG{n}{epsilon}\PYG{p}{)} 
\end{sphinxVerbatim}

\end{fulllineitems}



\section{Using the ‘CGModel()’ class to build coarse grained heteropolymers}
\label{\detokenize{cg_model:using-the-cgmodel-class-to-build-coarse-grained-heteropolymers}}
Shown below is a detailed description of the ‘CGModel()’ class object, as well as some of examples demonstrating how to use its functions and attributes.

\phantomsection\label{\detokenize{cg_model:module-cg_model.cgmodel}}\index{cg\_model.cgmodel (module)@\spxentry{cg\_model.cgmodel}\spxextra{module}}\index{CGModel (class in cg\_model.cgmodel)@\spxentry{CGModel}\spxextra{class in cg\_model.cgmodel}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{cg\_model.cgmodel.}}\sphinxbfcode{\sphinxupquote{CGModel}}}{\emph{positions=None, polymer\_length=12, backbone\_lengths={[}1{]}, sidechain\_lengths={[}1{]}, sidechain\_positions={[}0{]}, masses=\{'backbone\_bead\_masses': Quantity(value=100.0, unit=dalton), 'sidechain\_bead\_masses': Quantity(value=100.0, unit=dalton)\}, sigmas=\{'bb\_bb\_sigma': Quantity(value=1.875, unit=nanometer), 'bb\_sc\_sigma': Quantity(value=1.875, unit=nanometer), 'sc\_sc\_sigma': Quantity(value=1.875, unit=nanometer)\}, epsilons=\{'bb\_bb\_eps': Quantity(value=0.05, unit=kilocalorie/mole), 'sc\_sc\_eps': Quantity(value=0.05, unit=kilocalorie/mole)\}, bond\_lengths=\{'bb\_bb\_bond\_length': Quantity(value=0.75, unit=nanometer), 'bb\_sc\_bond\_length': Quantity(value=0.75, unit=nanometer), 'sc\_sc\_bond\_length': Quantity(value=0.75, unit=nanometer)\}, bond\_force\_constants=None, bond\_angle\_force\_constants=None, torsion\_force\_constants=None, equil\_bond\_angles=None, equil\_torsion\_angles=None, charges=None, constrain\_bonds=True, include\_bond\_forces=False, include\_nonbonded\_forces=True, include\_bond\_angle\_forces=True, include\_torsion\_forces=True, check\_energy\_conservation=True, use\_structure\_library=False, heteropolymer=False, monomer\_types=None, sequence=None, random\_positions=False}}{}
Build a coarse grained model class object.
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{foldamers}\PYG{n+nn}{.}\PYG{n+nn}{cg\PYGZus{}model}\PYG{n+nn}{.}\PYG{n+nn}{cgmodel} \PYG{k}{import} \PYG{n}{CGModel}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cgmodel} \PYG{o}{=} \PYG{n}{CGModel}\PYG{p}{(}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{foldamers}\PYG{n+nn}{.}\PYG{n+nn}{cg\PYGZus{}model}\PYG{n+nn}{.}\PYG{n+nn}{cgmodel} \PYG{k}{import} \PYG{n}{CGModel}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{simtk} \PYG{k}{import} \PYG{n}{unit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bond\PYGZus{}length} \PYG{o}{=} \PYG{l+m+mf}{7.5} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{angstrom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bond\PYGZus{}lengths} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bb\PYGZus{}bb\PYGZus{}bond\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{bond\PYGZus{}length}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bb\PYGZus{}sc\PYGZus{}bond\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{bond\PYGZus{}length}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sc\PYGZus{}sc\PYGZus{}bond\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{bond\PYGZus{}length}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{constrain\PYGZus{}bonds} \PYG{o}{=} \PYG{k+kc}{False}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cgmodel} \PYG{o}{=} \PYG{n}{CGModel}\PYG{p}{(}\PYG{n}{bond\PYGZus{}lengths}\PYG{o}{=}\PYG{n}{bond\PYGZus{}lengths}\PYG{p}{,}\PYG{n}{constrain\PYGZus{}bonds}\PYG{o}{=}\PYG{n}{constrain\PYGZus{}bonds}\PYG{p}{)}
\end{sphinxVerbatim}
\begin{quote}\begin{description}
\item[{Example}] \leavevmode
\end{description}\end{quote}

\fvset{hllines={, ,}}%
\begin{sphinxVerbatim}[commandchars=\\\{\}]
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{foldamers}\PYG{n+nn}{.}\PYG{n+nn}{cg\PYGZus{}model}\PYG{n+nn}{.}\PYG{n+nn}{cgmodel} \PYG{k}{import} \PYG{n}{CGModel}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{k+kn}{from} \PYG{n+nn}{simtk} \PYG{k}{import} \PYG{n}{unit}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{backbone\PYGZus{}length}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sidechain\PYGZus{}length}\PYG{o}{=}\PYG{l+m+mi}{1}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sidechain\PYGZus{}positions}\PYG{o}{=}\PYG{l+m+mi}{0}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{bond\PYGZus{}length} \PYG{o}{=} \PYG{l+m+mf}{7.5} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{angstrom}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sigma} \PYG{o}{=} \PYG{l+m+mf}{2.0} \PYG{o}{*} \PYG{n}{bond\PYGZus{}length}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{epsilon} \PYG{o}{=} \PYG{l+m+mf}{0.2} \PYG{o}{*} \PYG{n}{unit}\PYG{o}{.}\PYG{n}{kilocalorie\PYGZus{}per\PYGZus{}mole}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sigmas} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bb\PYGZus{}bb\PYGZus{}sigma}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sigma}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sc\PYGZus{}sc\PYGZus{}sigma}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sigma}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{epsilons} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bb\PYGZus{}bb\PYGZus{}eps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{epsilon}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bb\PYGZus{}sc\PYGZus{}eps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{epsilon}\PYG{p}{,}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sc\PYGZus{}sc\PYGZus{}eps}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{epsilon}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{A} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monomer\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{A}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{backbone\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{backbone\PYGZus{}length}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sidechain\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sidechain\PYGZus{}length}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sidechain\PYGZus{}positions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sidechain\PYGZus{}positions}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num\PYGZus{}beads}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{num\PYGZus{}beads}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bond\PYGZus{}lengths}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{bond\PYGZus{}lengths}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epsilons}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{epsilons}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigmas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sigmas}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{B} \PYG{o}{=} \PYG{p}{\PYGZob{}}\PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{monomer\PYGZus{}name}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{l+s+s2}{\PYGZdq{}}\PYG{l+s+s2}{B}\PYG{l+s+s2}{\PYGZdq{}}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{backbone\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{backbone\PYGZus{}length}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sidechain\PYGZus{}length}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sidechain\PYGZus{}length}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sidechain\PYGZus{}positions}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sidechain\PYGZus{}positions}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{num\PYGZus{}beads}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{num\PYGZus{}beads}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{bond\PYGZus{}lengths}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{bond\PYGZus{}lengths}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{epsilons}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{epsilons}\PYG{p}{,} \PYG{l+s+s1}{\PYGZsq{}}\PYG{l+s+s1}{sigmas}\PYG{l+s+s1}{\PYGZsq{}}\PYG{p}{:} \PYG{n}{sigmas}\PYG{p}{\PYGZcb{}}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{monomer\PYGZus{}types} \PYG{o}{=} \PYG{p}{[}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{sequence} \PYG{o}{=} \PYG{p}{[}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{A}\PYG{p}{,}\PYG{n}{B}\PYG{p}{]}
\PYG{g+gp}{\PYGZgt{}\PYGZgt{}\PYGZgt{} }\PYG{n}{cgmodel} \PYG{o}{=} \PYG{n}{CGModel}\PYG{p}{(}\PYG{n}{heteropolymer}\PYG{o}{=}\PYG{k+kc}{True}\PYG{p}{,}\PYG{n}{monomer\PYGZus{}types}\PYG{o}{=}\PYG{n}{monomer\PYGZus{}types}\PYG{p}{,}\PYG{n}{sequence}\PYG{o}{=}\PYG{n}{sequence}\PYG{p}{)}
\end{sphinxVerbatim}
\index{get\_all\_particle\_masses() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_all\_particle\_masses()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_all_particle_masses}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_all\_particle\_masses}}}{}{}
Returns a list of all unique particle masses
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
list\_of\_masses: List of unique particle masses

\item[{Return type}] \leavevmode

List( \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} )


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_angle\_force\_constant() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_angle\_force\_constant()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_angle_force_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_angle\_force\_constant}}}{\emph{particle\_1\_index}, \emph{particle\_2\_index}, \emph{particle\_3\_index}}{}
Determines the correct bond angle force constant for a bond angle between three particles, given their indices within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_1\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the first particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_2\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the second particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_3\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the third particle

\end{itemize}

\item[{Returns}] \leavevmode
bond\_angle\_force\_constant: The assigned bond angle force constant for the provided particles

\item[{Return type}] \leavevmode

bond\_angle\_force\_constant: \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_angle\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_angle\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_angle_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_angle\_list}}}{}{}
Construct a list of bond angles, which can be used to build bond angle potentials for the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
A list of indices for all of the bond angles in the coarse grained model

\item[{Return type}] \leavevmode
List( List( \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int} ) )

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_force\_constant() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_force\_constant()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_force_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_force\_constant}}}{\emph{particle\_1\_index}, \emph{particle\_2\_index}}{}
Determines the correct bond force constant for two particles, given their indices
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_1\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the first particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_2\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the second particle

\end{itemize}

\item[{Returns}] \leavevmode
bond\_force\_constant: The assigned bond force constant for the provided particles

\item[{Return type}] \leavevmode

bond\_length: \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_length() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_length()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_length}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_length}}}{\emph{particle\_1\_index}, \emph{particle\_2\_index}}{}
Determines the correct bond length for two particles, given their indices.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_1\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the first particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_2\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the second particle

\end{itemize}

\item[{Returns}] \leavevmode
bond\_length: The assigned bond length for the provided particles

\item[{Return type}] \leavevmode

bond\_length: \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_length\_from\_names() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_length\_from\_names()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_length_from_names}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_length\_from\_names}}}{\emph{particle\_1\_name}, \emph{particle\_2\_name}}{}
Determines the correct bond length for two particles, given their symbols.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_1\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name for the first particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_2\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name for the second particle

\end{itemize}

\item[{Returns}] \leavevmode
bond\_length: The assigned bond length for the provided particles

\item[{Return type}] \leavevmode

bond\_length: \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_bond\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_bond\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_bond_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_bond\_list}}}{}{}
Construct a bond list for the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
bond\_list: A list of the bonds in the coarse grained model.

\item[{Return type}] \leavevmode
bond\_list: List( List( \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int} ) )

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_epsilon() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_epsilon()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_epsilon}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_epsilon}}}{\emph{particle\_index}, \emph{particle\_type=None}}{}
Returns the Lennard-Jones potential epsilon value for a particle, given its index within the coarse grained model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Designates a particle as “backbone” or “sidechain”

\end{itemize}

\item[{Returns}] \leavevmode
epsilon: The assigned Lennard-Jones epsilon value for the provided particle index

\item[{Return type}] \leavevmode

\sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_equil\_bond\_angle() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_equil\_bond\_angle()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_equil_bond_angle}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_equil\_bond\_angle}}}{\emph{particle\_1\_index}, \emph{particle\_2\_index}, \emph{particle\_3\_index}}{}
Determines the correct equilibrium bond angle between three particles, given their indices within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_1\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the first particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_2\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the second particle

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_3\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index for the third particle

\end{itemize}

\item[{Returns}] \leavevmode
equil\_bond\_angle: The assigned equilibrium bond angle for the provided particles

\item[{Return type}] \leavevmode
equil\_bond\_angle: float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_equil\_torsion\_angle() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_equil\_torsion\_angle()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_equil_torsion_angle}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_equil\_torsion\_angle}}}{\emph{torsion}}{}
Determines the correct equilibrium angle for a torsion (bond angle involving four particles), given their indices within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{torsion}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{( }}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{ )}}) \textendash{} A list of the indices for the particles in a torsion

\end{itemize}

\item[{Returns}] \leavevmode
equil\_torsion\_angle: The assigned equilibrium torsion angle for the provided particles

\item[{Return type}] \leavevmode
equil\_torsion\_angle: float

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_monomer\_types() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_monomer\_types()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_monomer_types}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_monomer\_types}}}{}{}
Get a list of ‘monomer\_types’ for all unique monomers.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
monomer\_types: A list of unique monomer types in the coarse grained model

\item[{Return type}] \leavevmode

monomer\_types: List( dict( ‘monomer\_name’: str, ‘backbone\_length’: int, ‘sidechain\_length’: int, ‘sidechain\_positions’: List( int ), ‘num\_beads’: int, ‘bond\_lengths’: List( \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} ), ‘epsilons’: List( \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} ), ‘sigmas’: List( \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} ) ) )


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nonbonded\_exclusion\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_nonbonded\_exclusion\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_nonbonded_exclusion_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_nonbonded\_exclusion\_list}}}{}{}
Get a list of the nonbonded interaction exclusions, which are assigned if two particles are separated by less than three bonds
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
exclusion\_list: A list of the nonbonded particle interaction exclusions for the coarse grained model

\item[{Return type}] \leavevmode
List( List( \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int} ) )

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_nonbonded\_interaction\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_nonbonded\_interaction\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_nonbonded_interaction_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_nonbonded\_interaction\_list}}}{}{}
Construct a nonbonded interaction list for the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
interaction\_list: A list of the nonbonded interactions (which don’t violate exclusion rules) in the coarse grained model

\item[{Return type}] \leavevmode
interaction\_list: List( List( \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int} ) )

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_num\_beads() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_num\_beads()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_num_beads}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_num\_beads}}}{}{}
Calculate the number of beads in a coarse grained model class object
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
num\_beads: The total number of beads in the coarse grained model

\item[{Return type}] \leavevmode
num\_beads: int

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_particle\_charge() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_particle\_charge()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_particle_charge}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_particle\_charge}}}{\emph{particle\_index}}{}
Returns the charge for a particle, given its index within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\end{itemize}

\item[{Returns}] \leavevmode
particle\_charge: The charge for the provided particle index

\item[{Return type}] \leavevmode

\sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_particle\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_particle\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_particle_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_particle\_list}}}{}{}
Get a list of particles, where the indices correspond to those in the system/topology.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
particle\_list: A list of unique particles in the coarse grained model

\item[{Return type}] \leavevmode
particle\_list: List( \sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{str} )

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_particle\_mass() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_particle\_mass()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_particle_mass}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_particle\_mass}}}{\emph{particle\_index}}{}
Get the mass for a particle, given its index within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\end{itemize}

\item[{Returns}] \leavevmode
particle\_mass: The mass for the provided particle index

\item[{Return type}] \leavevmode

\sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_particle\_name() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_particle\_name()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_particle_name}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_particle\_name}}}{\emph{particle\_index}}{}
Returns the name of a particle, given its index within the model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\end{itemize}

\item[{Returns}] \leavevmode
particle\_name: The name of the particle

\item[{Return type}] \leavevmode
particle\_name: str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_particle\_type() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_particle\_type()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_particle_type}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_particle\_type}}}{\emph{particle\_index}, \emph{particle\_name=None}}{}
Indicates if a particle is a backbone bead or a sidechain bead
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_name}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Name of the particle that we would like to “type”.

\end{itemize}

\item[{Returns}] \leavevmode
particle\_type: ‘backbone’ or ‘sidechain’

\item[{Return type}] \leavevmode
particle\_type: str

\end{description}\end{quote}

\end{fulllineitems}

\index{get\_sigma() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_sigma()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_sigma}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_sigma}}}{\emph{particle\_index}, \emph{particle\_type=None}}{}
Returns the Lennard-Jones potential sigma value for a particle, given its index within the coarse grained model.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_index}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} Index of the particle for which we would like to determine the type

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{particle\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Designates a particle as “backbone” or “sidechain”

\end{itemize}

\item[{Returns}] \leavevmode
sigma: The assigned Lennard-Jones sigma value for the provided particle index

\item[{Return type}] \leavevmode

\sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_torsion\_force\_constant() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_torsion\_force\_constant()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_torsion_force_constant}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_torsion\_force\_constant}}}{\emph{torsion}}{}
Determines the correct torsion force constant for a torsion (bond angle involving four particles), given their indices within the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{torsion}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{( }}\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}\sphinxstyleliteralemphasis{\sphinxupquote{ )}}) \textendash{} A list of the indices for the particles in a torsion

\end{itemize}

\item[{Returns}] \leavevmode
torsion\_force\_constant: The assigned torsion force constant for the provided particles

\item[{Return type}] \leavevmode

torsion\_force\_constant: \sphinxhref{https://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_torsion\_list() (cg\_model.cgmodel.CGModel method)@\spxentry{get\_torsion\_list()}\spxextra{cg\_model.cgmodel.CGModel method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.get_torsion_list}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{get\_torsion\_list}}}{}{}
Construct a list of particle indices from which to define torsions for the coarse grained model
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{CGModel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item[{Returns}] \leavevmode
torsions: A list of the particle indices for the torsions in the coarse grained model

\item[{Return type}] \leavevmode
torsions: List( List( \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int}, \sphinxhref{https://docs.python.org/3/library/functions.html\#int}{int} ) )

\end{description}\end{quote}

\end{fulllineitems}

\index{nonbonded\_interaction\_list (cg\_model.cgmodel.CGModel attribute)@\spxentry{nonbonded\_interaction\_list}\spxextra{cg\_model.cgmodel.CGModel attribute}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{cg_model:cg_model.cgmodel.CGModel.nonbonded_interaction_list}}\pysigline{\sphinxbfcode{\sphinxupquote{nonbonded\_interaction\_list}}\sphinxbfcode{\sphinxupquote{ = None}}}
Initialize new (coarse grained) particle types:

\end{fulllineitems}


\end{fulllineitems}



\chapter{Ensemble building tools}
\label{\detokenize{ensembles:ensemble-building-tools}}\label{\detokenize{ensembles::doc}}
The foldamers package contains several tools for building conformational ensembles.  The \sphinxhref{http://mdtraj.org}{MDTraj} and \sphinxhref{http://msmbuilder.org/}{MSMBuilder} packages are leveraged to perform structural analyses in order to identify poses that are structurally similar.


\section{Using MSMBuilder to generate conformational ensembles}
\label{\detokenize{ensembles:using-msmbuilder-to-generate-conformational-ensembles}}
The foldamers package allows the user to apply K-means clustering tools from MSMBuilder in order to search for ensembles of poses that are structurally similar.  The centroid configurations for individual clusters are used as a reference, and ensembles are defined by including all structures that fall below an RMSD positions threshold (\textless{}2 Angstroms).


\section{Native structure-based ensemble generation tools}
\label{\detokenize{ensembles:native-structure-based-ensemble-generation-tools}}
The foldamers package allows the user to build “native” and “nonnative” structural ensembles, and to evaluate their energetic differences with the Z-score.  These tools require identification of a “native” structure.

\phantomsection\label{\detokenize{ensembles:module-ensembles.ens_build}}\index{ensembles.ens\_build (module)@\spxentry{ensembles.ens\_build}\spxextra{module}}\index{get\_ensembles() (in module ensembles.ens\_build)@\spxentry{get\_ensembles()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_ensembles}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_ensembles}}}{\emph{cgmodel}, \emph{native\_structure}, \emph{ensemble\_size=None}}{}
\end{fulllineitems}

\index{get\_native\_ensemble() (in module ensembles.ens\_build)@\spxentry{get\_native\_ensemble()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_native_ensemble}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_native\_ensemble}}}{\emph{cgmodel}, \emph{native\_structure}, \emph{ensemble\_size=10}, \emph{native\_fraction\_cutoff=0.9}, \emph{rmsd\_cutoff=10.0}, \emph{ensemble\_build\_method='native\_contacts'}}{}
\end{fulllineitems}

\index{get\_nonnative\_ensemble() (in module ensembles.ens\_build)@\spxentry{get\_nonnative\_ensemble()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_nonnative_ensemble}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_nonnative\_ensemble}}}{\emph{cgmodel}, \emph{native\_structure}, \emph{ensemble\_size=100}, \emph{native\_fraction\_cutoff=0.75}, \emph{rmsd\_cutoff=10.0}, \emph{ensemble\_build\_method='native\_contacts'}}{}
\end{fulllineitems}

\index{z\_score() (in module ensembles.ens\_build)@\spxentry{z\_score()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.z_score}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{z\_score}}}{\emph{topology}, \emph{system}, \emph{nonnative\_ensemble\_energies}, \emph{native\_ensemble\_energies}}{}
Given an ensemble of nonnative structures, and a low-energy (“native”) structure, this subroutine will calculate the Z-score.
\begin{description}
\item[{nonnative\_ensemble: List( positions( np.array( float * simtk.unit ( shape = num\_beads x 3 ) ) )}] \leavevmode
A list of the positions for all members in the high\_energy ensemble.

\item[{native\_structure: positions( np.array( float * simtk.unit ( shape = num\_beads x 3 ) )}] \leavevmode
The positions for a low energy structure.

\end{description}

\end{fulllineitems}



\section{Energy-based ensemble generation tools}
\label{\detokenize{ensembles:energy-based-ensemble-generation-tools}}
The foldamers package allows the user to build structural ensembles that exhibit similar energies.  Shown below are tools that enable energy-based ensemble generation.

\phantomsection\label{\detokenize{ensembles:module-ensembles.ens_build}}\index{ensembles.ens\_build (module)@\spxentry{ensembles.ens\_build}\spxextra{module}}\index{get\_ensemble() (in module ensembles.ens\_build)@\spxentry{get\_ensemble()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_ensemble}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_ensemble}}}{\emph{cgmodel}, \emph{ensemble\_size=100}, \emph{high\_energy=False}, \emph{low\_energy=False}}{}
Given a coarse grained model, this function generates an ensemble of high energy configurations and, by default, saves this ensemble to the foldamers/ensembles database for future reference/use, if a high-energy ensemble with these settings does not already exist.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cgmodel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_size}} (\sphinxstyleliteralemphasis{\sphinxupquote{integer}}) \textendash{} Number of structures to generate for this ensemble, default = 100

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{high\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of high-energy structures, default = False

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{low\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of low-energy structures, default = False

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
ensemble (List(positions(np.array(float*simtk.unit (shape = num\_beads x 3))))) - A list of the positions for all members in the ensemble.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{test\_energy() (in module ensembles.ens\_build)@\spxentry{test\_energy()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.test_energy}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{test\_energy}}}{\emph{energy}}{}
Given an energy, this function determines if that energy is too large to be “physical”.  This function is used to determine if the user-defined input parameters for a coarse grained model give a reasonable potential function.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{energy}} (\sphinxhref{http://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} or float) \textendash{} The energy to test.

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
pass\_energy\_test ( Logical ) - A variable indicating if the energy passed (“True”) or failed (“False”) a “sanity” test for the model’s energy.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{improve\_ensemble() (in module ensembles.ens\_build)@\spxentry{improve\_ensemble()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.improve_ensemble}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{improve\_ensemble}}}{\emph{energy}, \emph{positions}, \emph{ensemble}, \emph{ensemble\_energies}, \emph{unchanged\_iterations}}{}
Given an energy and positions for a single pose, as well as the same data for a reference ensemble, this function “improves” the quality of the ensemble by identifying poses with the lowest potential energy.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{energy}} \textendash{} The energy for a pose.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{positions}} \textendash{} Positions for coarse grained particles in the model, default = None

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble}} (\sphinxstyleliteralemphasis{\sphinxupquote{List}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{positions}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{np.array}}\sphinxstyleliteralemphasis{\sphinxupquote{(}}\sphinxstyleliteralemphasis{\sphinxupquote{float*simtk.unit}}\sphinxstyleliteralemphasis{\sphinxupquote{ (}}\sphinxstyleliteralemphasis{\sphinxupquote{shape = num\_beads x 3}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}\sphinxstyleliteralemphasis{\sphinxupquote{)}}) \textendash{} A group of similar poses.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_energies}} \textendash{} A list of energies for a conformational ensemble.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{unchanged\_iterations}} (\sphinxhref{https://docs.python.org/3/library/functions.html\#int}{\sphinxstyleliteralemphasis{\sphinxupquote{int}}}) \textendash{} The number of iterations for which the ensemble has gone unchanged.

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
ensemble (List(positions(np.array(float*simtk.unit (shape = num\_beads x 3))))) - A list of the positions for all members in the ensemble.

\item {} 
ensemble\_energies ( List(\sphinxhref{http://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} )) - A list of the energies that were stored in the PDB files for the ensemble, if any.

\item {} 
unchanged\_iterations ( int ) - The number of iterations for which the ensemble has gone unchanged.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}



\section{Writing and reading ensemble data from the ‘foldamers’ database}
\label{\detokenize{ensembles:writing-and-reading-ensemble-data-from-the-foldamers-database}}
The foldamers package is designed to store the low-energy poses from simulation runs of new (previously un-modelled) coarse grained representations.  At present, the package does not enable storage of heteropolymers, in order to minimize the size of the database.  For homopolymers, the syntax for assigning directory names for coarse grained model data is as follows:

directory\_name = str( “foldamers/ensembles/” + str(polymer\_length) + “\_” + str(backbone\_length) + “\_” + str(sidechain\_length) “\_” + str(sidechain\_positions) + “\_” + str(bb\_bb\_bond\_length) + “\_” + str(sc\_bb\_bond\_length) + “\_” + str(sc\_sc\_bond\_length) )

For example, the directory name for a model with 20 monomers, all of which contain one backbone bead and one sidechain bead, and whose bond lengths are all 7.5 Angstroms, would be: “foldamers/ensembles/20\_1\_1\_0\_7.5\_7.5\_7.5”.

The following functions are used to read and write ensemble data to the foldamers database (located in ‘foldamers/ensembles’).

\phantomsection\label{\detokenize{ensembles:module-ensembles.ens_build}}\index{ensembles.ens\_build (module)@\spxentry{ensembles.ens\_build}\spxextra{module}}\index{get\_ensemble\_directory() (in module ensembles.ens\_build)@\spxentry{get\_ensemble\_directory()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_ensemble_directory}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_ensemble\_directory}}}{\emph{cgmodel}, \emph{ensemble\_type=None}}{}
Given a CGModel() class object, this function uses its attributes to assign an ensemble directory name.

For example, the directory name for a model with 20 monomers, all of which contain one backbone bead and one sidechain bead, and whose bond lengths are all 7.5 Angstroms, would be: “foldamers/ensembles/20\_1\_1\_0\_7.5\_7.5\_7.5”.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cgmodel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_type}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Designates the type of ensemble for which we will assign a directory name.  default = None.  Valid options include: “native” and “nonnative”

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
ensemble\_directory ( str ) - The path/name for the ensemble directory.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{write\_ensemble\_pdb() (in module ensembles.ens\_build)@\spxentry{write\_ensemble\_pdb()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.write_ensemble_pdb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{write\_ensemble\_pdb}}}{\emph{cgmodel}, \emph{ensemble\_directory=None}}{}
Given a CGModel() class object that contains positions, this function writes a PDB file for the coarse grained model, using those positions.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cgmodel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_directory}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Path to a folder containing PDB files, default = None

\end{itemize}

\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
If no ‘ensemble\_directory’ is provided, the
\end{sphinxadmonition}

\end{fulllineitems}

\index{get\_pdb\_list() (in module ensembles.ens\_build)@\spxentry{get\_pdb\_list()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_pdb_list}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_pdb\_list}}}{\emph{ensemble\_directory}}{}
Given an ‘ensemble\_directory’, this function retrieves a list of the PDB files within it.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_directory}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} Path to a folder containing PDB files

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
pdb\_list ( List(str) ) - A list of the PDB files in the provided ‘ensemble\_directory’.

\end{itemize}


\end{description}\end{quote}

\end{fulllineitems}

\index{get\_ensemble\_data() (in module ensembles.ens\_build)@\spxentry{get\_ensemble\_data()}\spxextra{in module ensembles.ens\_build}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{ensembles:ensembles.ens_build.get_ensemble_data}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{ensembles.ens\_build.}}\sphinxbfcode{\sphinxupquote{get\_ensemble\_data}}}{\emph{cgmodel}, \emph{ensemble\_directory}}{}
Given a CGModel() class object and an ‘ensemble\_directory’, this function reads the PDB files within that directory, as well as any energy data those files contain.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{cgmodel}} (\sphinxstyleliteralemphasis{\sphinxupquote{class}}) \textendash{} CGModel() class object

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{ensemble\_directory}} (\sphinxhref{https://docs.python.org/3/library/stdtypes.html\#str}{\sphinxstyleliteralemphasis{\sphinxupquote{str}}}) \textendash{} The path/name of the directory where PDB files for this ensemble are stored

\end{itemize}

\item[{Returns}] \leavevmode
\begin{itemize}
\item {} 
ensemble (List(positions(np.array(float*simtk.unit (shape = num\_beads x 3))))) - A list of the positions for all members in the ensemble.

\item {} 
ensemble\_energies ( List(\sphinxhref{http://docs.openmm.org/development/api-python/generated/simtk.unit.quantity.Quantity.html}{Quantity()} )) - A list of the energies that were stored in the PDB files for the ensemble, if any.

\end{itemize}


\end{description}\end{quote}

\begin{sphinxadmonition}{warning}{Warning:}
When energies are written to a PDB file, only the sigma and epsilon values for the model are written to the file with the positions.  Unless the user is confident about the model parameters that were used to generate the energies in the PDB files, it is probably best to re-calculate their energies.  This can be done with the ‘cg\_openmm’ package.  More specifically, one can compute an updated energy for individual ensemble members, with the current coarse grained model parameters, with ‘get\_mm\_energy’, a function in ‘cg\_openmm/cg\_openmm/simulation/tools.py’.
\end{sphinxadmonition}

\end{fulllineitems}



\chapter{Thermodynamic analysis tools for coarse grained modeling}
\label{\detokenize{thermo:thermodynamic-analysis-tools-for-coarse-grained-modeling}}\label{\detokenize{thermo::doc}}
This page details the functions and classes in src/thermo


\section{Tools to calculate the heat capacity with pymbar}
\label{\detokenize{thermo:tools-to-calculate-the-heat-capacity-with-pymbar}}
Shown below are functions/tools used in order to calculate
the heat capacity with pymbar.


\chapter{Utilities for the ‘foldamers’ package}
\label{\detokenize{utilities:utilities-for-the-foldamers-package}}\label{\detokenize{utilities::doc}}
This page details the functions and classes in src/util.


\section{Input/Output options (src/utilities/iotools.py)}
\label{\detokenize{utilities:input-output-options-src-utilities-iotools-py}}
Shown below is a detailed description of the input/output
options for the foldamers package.

\phantomsection\label{\detokenize{utilities:module-utilities.iotools}}\index{utilities.iotools (module)@\spxentry{utilities.iotools}\spxextra{module}}\index{write\_bonds() (in module utilities.iotools)@\spxentry{write\_bonds()}\spxextra{in module utilities.iotools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.iotools.write_bonds}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.iotools.}}\sphinxbfcode{\sphinxupquote{write\_bonds}}}{\emph{CGModel}, \emph{pdb\_object}}{}
Writes the bonds from an input CGModel class object to the file object ‘pdb\_object’, using PDB ‘CONECT’ syntax.

CGModel: Coarse grained model class object

pdb\_object: File object to which we will write the bond list

\end{fulllineitems}

\index{write\_cg\_pdb() (in module utilities.iotools)@\spxentry{write\_cg\_pdb()}\spxextra{in module utilities.iotools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.iotools.write_cg_pdb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.iotools.}}\sphinxbfcode{\sphinxupquote{write\_cg\_pdb}}}{\emph{cgmodel}, \emph{file\_name}}{}
Writes the positions from an input CGModel class object to the file ‘filename’.  Used to test the compatibility of coarse grained model parameters with the OpenMM PDBFile() functions, which are needed to write coordinates to a PDB file during MD simulations.

CGModel: Coarse grained model class object

filename: Path to the file where we will write PDB coordinates.

\end{fulllineitems}

\index{write\_pdbfile\_without\_topology() (in module utilities.iotools)@\spxentry{write\_pdbfile\_without\_topology()}\spxextra{in module utilities.iotools}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.iotools.write_pdbfile_without_topology}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.iotools.}}\sphinxbfcode{\sphinxupquote{write\_pdbfile\_without\_topology}}}{\emph{CGModel}, \emph{filename}, \emph{energy=None}}{}
Writes the positions from an input CGModel class object to the file ‘filename’.

CGModel: Coarse grained model class object

filename: Path to the file where we will write PDB coordinates.

energy: Energy to write to the PDB file, default = None

\end{fulllineitems}



\section{Utilities and random functions (src/utilities/util.py)}
\label{\detokenize{utilities:module-utilities.util}}\label{\detokenize{utilities:utilities-and-random-functions-src-utilities-util-py}}\index{utilities.util (module)@\spxentry{utilities.util}\spxextra{module}}\index{assign\_position() (in module utilities.util)@\spxentry{assign\_position()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.assign_position}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{assign\_position}}}{\emph{positions}, \emph{bond\_length}, \emph{sigma}, \emph{bead\_index}, \emph{parent\_index}}{}
Assign random position for a bead

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

bond\_length: Bond length for all beads that are bonded,
( float * simtk.unit.distance )
default = 1.0 * unit.angstrom

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

\end{fulllineitems}

\index{assign\_position\_lattice\_style() (in module utilities.util)@\spxentry{assign\_position\_lattice\_style()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.assign_position_lattice_style}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{assign\_position\_lattice\_style}}}{\emph{cgmodel}, \emph{positions}, \emph{distance\_cutoff}, \emph{parent\_bead\_index}, \emph{bead\_index}}{}
Assign random position for a bead

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

bond\_length: Bond length for all beads that are bonded,
( float * simtk.unit.distance )
default = 1.0 * unit.angstrom

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

\end{fulllineitems}

\index{attempt\_lattice\_move() (in module utilities.util)@\spxentry{attempt\_lattice\_move()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.attempt_lattice_move}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{attempt\_lattice\_move}}}{\emph{parent\_coordinates}, \emph{bond\_length}, \emph{move\_direction\_list}}{}
Given a set of cartesian coordinates, assign a new particle
a distance of ‘bond\_length’ away in a random direction.

parent\_coordinates: Positions for a single particle,
away from which we will place a new particle a distance
of ‘bond\_length’ away.
( np.array( float * unit.angstrom ( length = 3 ) ) )

bond\_length: Bond length for all beads that are bonded,
( float * simtk.unit.distance )
default = 1.0 * unit.angstrom

trial\_coordinates: Positions for a new trial particle
( np.array( float * unit.angstrom ( length = 3 ) ) )

\end{fulllineitems}

\index{attempt\_move() (in module utilities.util)@\spxentry{attempt\_move()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.attempt_move}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{attempt\_move}}}{\emph{parent\_coordinates}, \emph{bond\_length}}{}
Given a set of cartesian coordinates, assign a new particle
a distance of ‘bond\_length’ away in a random direction.

parent\_coordinates: Positions for a single particle,
away from which we will place a new particle a distance
of ‘bond\_length’ away.
( np.array( float * unit.angstrom ( length = 3 ) ) )

bond\_length: Bond length for all beads that are bonded,
( float * simtk.unit.distance )
default = 1.0 * unit.angstrom

trial\_coordinates: Positions for a new trial particle
( np.array( float * unit.angstrom ( length = 3 ) ) )

\end{fulllineitems}

\index{collisions() (in module utilities.util)@\spxentry{collisions()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.collisions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{collisions}}}{\emph{positions}, \emph{distance\_list}, \emph{distance\_cutoff}}{}
Determine whether there are any collisions between non-bonded
particles, where a “collision” is defined as a distance shorter
than the user-provided ‘bond\_length’.

distances: List of the distances between all nonbonded particles.
( list ( float * simtk.unit.distance ( length = \# nonbonded\_interactions ) ) )

bond\_length: Bond length for all beads that are bonded,
( float * simtk.unit.distance )
default = 1.0 * unit.angstrom

collision: Logical variable stating whether or not the model has
bead collisions.
default = False

\end{fulllineitems}

\index{distance() (in module utilities.util)@\spxentry{distance()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.distance}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{distance}}}{\emph{positions\_1}, \emph{positions\_2}}{}
Construct a matrix of the distances between all particles.

positions\_1: Positions for a particle
( np.array( length = 3 ) )

positions\_2: Positions for a particle
( np.array( length = 3 ) )

distance
( float * unit )

\end{fulllineitems}

\index{distance\_matrix() (in module utilities.util)@\spxentry{distance\_matrix()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.distance_matrix}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{distance\_matrix}}}{\emph{positions}}{}
Construct a matrix of the distances between all particles.

positions: Positions for an array of particles.
( np.array( num\_particles x 3 ) )

distance\_matrix: Matrix containing the distances between all beads.
( np.array( num\_particles x 3 ) )

\end{fulllineitems}

\index{distances() (in module utilities.util)@\spxentry{distances()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.distances}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{distances}}}{\emph{interaction\_list}, \emph{positions}}{}
Calculate the distances between a trial particle (‘new\_coordinates’)
and all existing particles (‘existing\_coordinates’).

new\_coordinates: Positions for a single trial particle
( np.array( float * unit.angstrom ( length = 3 ) ) )

existing\_coordinates: Positions for a single trial particle
( np.array( float * unit.angstrom ( shape = num\_particles x 3 ) ) )

distances: List of the distances between all nonbonded particles.
( list ( float * simtk.unit.distance ( length = \# nonbonded\_interactions ) ) )

\end{fulllineitems}

\index{first\_bead() (in module utilities.util)@\spxentry{first\_bead()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.first_bead}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{first\_bead}}}{\emph{positions}}{}
Determine if we have any particles in ‘positions’
positions: Positions for all beads in the coarse-grained model.
( np.array( float * unit ( shape = num\_beads x 3 ) ) )
first\_bead: Logical variable stating if this is the first particle.

\end{fulllineitems}

\index{get\_move() (in module utilities.util)@\spxentry{get\_move()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.get_move}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{get\_move}}}{\emph{trial\_coordinates}, \emph{move\_direction}, \emph{distance}, \emph{bond\_length}, \emph{finish\_bond=False}}{}
Given a ‘move\_direction’, a current distance, and a
target ‘bond\_length’ ( Index denoting x,y,z Cartesian 
direction), update the coordinates for the particle.

trial\_coordinates: positions for a particle
( np.array( float * unit.angstrom ( length = 3 ) ) )

move\_direction: Cartesian direction in which we will
attempt a particle placement, where: x=0, y=1, z=2. 
( integer )

distance: Current distance from parent particle
( float * simtk.unit.distance )

bond\_length: Target bond\_length for particle placement.
( float * simtk.unit.distance )

finish\_bond: Logical variable determining how we will
update the coordinates for this particle.

trial\_coordinates: Updated positions for the particle
( np.array( float * unit.angstrom ( length = 3 ) ) )

\end{fulllineitems}

\index{get\_structure\_from\_library() (in module utilities.util)@\spxentry{get\_structure\_from\_library()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.get_structure_from_library}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{get\_structure\_from\_library}}}{\emph{cgmodel}, \emph{high\_energy=False}, \emph{low\_energy=False}}{}
Given a coarse grained model class object, this function retrieves
a set of positions for the model from the ensemble library, in:
‘../foldamers/ensembles/\$\{backbone\_length\}\_\$\{sidechain\_length\}\_\$\{sidechain\_positions\}’
If this coarse grained model does not have an ensemble library, an 
error message will be returned and we will attempt to assign 
positions at random with ‘random\_positions()’.

cgmodel: CGModel() class object.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{high\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of high-energy structures, default = False

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{low\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of low-energy structures, default = False

\end{itemize}

\end{description}\end{quote}

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

\end{fulllineitems}

\index{random\_positions() (in module utilities.util)@\spxentry{random\_positions()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.random_positions}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{random\_positions}}}{\emph{cgmodel}, \emph{max\_attempts=1000}, \emph{use\_library=False}, \emph{high\_energy=False}, \emph{low\_energy=False}, \emph{generate\_library=False}}{}
Assign random positions for all beads in a coarse-grained polymer.

cgmodel: CGModel() class object.

max\_attempts: The maximum number of times that we will attempt to build
a coarse grained model with the settings in ‘cgmodel’.
default = 1000

use\_library: A logical variable determining if we will generate a new
random structure, or take a random structure from the library in the following path:
‘../foldamers/ensembles/\$\{backbone\_length\}\_\$\{sidechain\_length\}\_\$\{sidechain\_positions\}’
default = True
( NOTE: By default, if use\_library = False, new structures will be added to the
\begin{quote}

ensemble library for the relevant coarse grained model.  If that model does not
have an ensemble library, one will be created. )
\end{quote}
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{high\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of high-energy structures, default = False

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{low\_energy}} (\sphinxstyleliteralemphasis{\sphinxupquote{Logical}}) \textendash{} If set to ‘True’, this function will generate an ensemble of low-energy structures, default = False

\end{itemize}

\end{description}\end{quote}

positions: Positions for all beads in the coarse-grained model.
( np.array( num\_beads x 3 ) )

\end{fulllineitems}

\index{random\_sign() (in module utilities.util)@\spxentry{random\_sign()}\spxextra{in module utilities.util}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{utilities:utilities.util.random_sign}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{utilities.util.}}\sphinxbfcode{\sphinxupquote{random\_sign}}}{\emph{number}}{}
Returns ‘number’ with a random sign.

number: float

number

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{cg\_model.cgmodel}\sphinxstyleindexpageref{cg_model:\detokenize{module-cg_model.cgmodel}}
\indexspace
\bigletter{e}
\item\relax\sphinxstyleindexentry{ensembles.ens\_build}\sphinxstyleindexpageref{ensembles:\detokenize{module-ensembles.ens_build}}
\indexspace
\bigletter{u}
\item\relax\sphinxstyleindexentry{utilities.iotools}\sphinxstyleindexpageref{utilities:\detokenize{module-utilities.iotools}}
\item\relax\sphinxstyleindexentry{utilities.util}\sphinxstyleindexpageref{utilities:\detokenize{module-utilities.util}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}